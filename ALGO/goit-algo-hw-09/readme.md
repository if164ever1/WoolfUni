# Порівняння ефективності жадібного алгоритму та динамічного програмування

## Аналіз продуктивності

### Часова складність
- **Жадібний алгоритм**: O(n), де n - кількість номіналів монет (у нашому випадку 6)
- **Динамічне програмування**: O(m*n), де m - сума решти, n - кількість номіналів монет

### Практичні виміри часу
На основі тестів для суми 99,999:
- Жадібний алгоритм: ~0.00000 сек
- Динамічне програмування: ~0.093680 сек

## Ключові відмінності

### Жадібний алгоритм
**Переваги**:
- Надзвичайно швидкий (константний час для фіксованого набору монет)
- Простий у реалізації
- Ефективно використовує пам'ять (O(1) додаткової пам'яті)

**Недоліки**:
- Не завжди знаходить оптимальне рішення (для деяких наборів монет)
- Оптимальний тільки для канонічних систем монет (як у нашому випадку)

### Динамічне програмування
**Переваги**:
- Завжди знаходить оптимальне рішення (мінімальна кількість монет)
- Універсальне для будь-яких наборів монет

**Недоліки**:
- Вимагає значно більше часу для великих сум
- Використовує O(m) додаткової пам'яті (що критично для дуже великих сум)

## Висновки

1. **Для стандартних наборів монет** (як у нашому випадку - [50, 25, 10, 5, 2, 1]):
   - Жадібний алгоритм є кращим вибором
   - Дає той самий оптимальний результат, що й динамічне програмування
   - Працює на порядки швидше
   - Вимагає мінімальних ресурсів

2. **Для нестандартних наборів монет**:
   - Динамічне програмування є єдиною гарантовано оптимальною альтернативою
   - Жадібний алгоритм може давати неоптимальні результати

3. **Для дуже великих сум** (понад 1,000,000):
   - Жадібний алгоритм залишається ефективним
   - Динамічне програмування може стати непрактичним через вимоги до пам'яті та часу

4. **Рекомендації для реалізації**:
   - У реальних касових системах зі стандартними монетами використовувати жадібний алгоритм
   - Динамічне програмування застосовувати лише для спеціальних випадків з нестандартними номіналами
   - Для дуже великих сум обов'язково проводити тестування продуктивності

## Оптимізаційні міркування

У випадку, коли потрібно обробляти дуже великі суми (наприклад, в банківських системах), можна розглянути гібридний підхід:
1. Спочатку перевірити, чи система монет є канонічною (підходить для жадібного алгоритму)
2. Якщо так - використовувати жадібний алгоритм
3. Якщо ні - застосовувати динамічне програмування з оптимізаціями (наприклад, мемоізацією)